# GraphRoads
1 Задание

Для получения результатов необходимо запустить скрипт "main.ipynb". (Первым был загружен скрипт run.ipynb, но в нем много лишнего)
В скрипте есть поясняющие комментарии. К сожалению, исходный файл xml весил 56 Мб и не загрузился. Матрица смежности не получилась из-за большого размера, но описан алгоритм ее построения.

Для парсинга xml используется библиотека lxml, etree, objectify. 
Отбираем дороги из тегов way, в которых указан tag с атрибутом k = highway. 
Затем создается словарь для быстрого получения по номеру узла его координат.
Создаем словарь, в котором номеру узла соответствует количество его вхождений в дороги.
Создаем словарь, в котором номеру узла соответствует количество ребер ему инцидентных. (Ребер в одной дороге n - 1, где n - количество узлов в дороге)
Удалить ненобходимо те узлы, которые имеют степень 2 и встречаются в 1 дороге или не встречаются вообще ни в одной дороге.
Для удобства вся отрисовка графиков закомментирована. 
Создаем словарь списка смежности по принципу: если текущий узел в дороге не необходим к удалению то его и следующий узел записываем в список смежности по соответствующему ключу, так как два этих узла будут образовывать ребро. (если следующий тоже не необходим к удалению, и т д)
Убираем из списка смежности повторяющиеся значения вершин. 
В csv файл списка смежности записываем словарь списка смежности. (В первом столбце id вершины)
В матрицу смежности записываем построчно массив из нулей, в котором на месте ребра для данного узла стоят 1.

В результате получены: 
test_sochi.png - исходная отрисовка дорог, без удаления лишиних узлов.
test_sochi2.png - то же самое в большом разрешении.
testo_sochi.jpg - отрисовка по веришинам, которые остались после удаления.
mini-sochi_map2.jpg - скриншот исходной карты для сравнения.

2 Задание

В связи с тем, что полученный граф города Сочи имел очень много компонент связности, я взяла другой город - Таганрог. Исходный файл xml также не загрузился, т к весил 30 Мб. Исходный полученный граф сохранен в taganrog_original.png, с удаленными лишними вершинами в  taganrog.png. 

Чтобы получить результат необходимо запустить скрипт "main2.ipynb". В нем есть поясняющие комментарии. 
В начале так же как в первом задании считываются узлы, ребра. 
По всем вершинам проходим циклом, ищем тег tag, считываем больницы по атрибуту тега v = 'hospital'. Получается 8 больниц. Проходим по всем узлам, ищем ближайщие к больницам вершины, записываем их в target.
С помощью интерфейса для ввода координат вводим нужные координаты. Пробегая по всем вершинам находим самую близкую к введенной. Обозначим ее как start. 

Мной были реализованы алгоритмы Дейкстры и Левита, но Дейкстра в среднем работает 90 секунд, а Левит 13. Поэтому собственную реализацию Дейкстры я в дальнейшем не вызываю. Результаты алгоритмы выдавали одинаковые.

В дальнейшем импортируется библиотека для работы с графами networkx. В ней есть готовые реализации алгоритмов Дейкстры и А стар. Для А стар я написала 3 эвристических функции измерения расстояния: Чебышева, Манхеттоновское и Евклидово.

Кратчайшие пути между стартовой точкой и 8 больницами отрисованы с помощью готовой реализации алгоритма Дейкстры из networkx. С помощью этой библиотеки визуализированы результаты и сохранены в файлах "ShortestWay__номер узла исходного__номер узла назначения.png". Маршруты записаны в файлы с таким же названием ".csv".

В файле Statistics_100_points.csv записаны результаты вычисления маршрутов для 100 случайных точек алгоритмами Дейкстра(реализация networkx), Левит(моя реализация), A*(Евлида), A*(манхеттеновское), A*(чебышева) (А* реализация из библиотеки networkx)


3 задание

Реализованы два алгоритма для решения задачи коммивояжера: поиска ближайшего соседа и добавление вершины в цикл, с получением наименьшего периметра. Результаты получились одинаковыми. Код содержится в файле main3.ipynb. Так же в нем находится код для расчета и записи в файл вреднего времени для подъезда к токам из предыдущего задания. Так же выложена презентация проекта. 
